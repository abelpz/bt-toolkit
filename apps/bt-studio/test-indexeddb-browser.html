re in a monbecause they were hanging
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IndexedDB Storage Adapter Test</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border-left: 4px solid #3498db;
            background-color: #f8f9fa;
        }
        .test-result {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
        }
        .success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .info {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        .warning {
            background-color: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
            font-size: 14px;
        }
        button:hover {
            background-color: #2980b9;
        }
        button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .stat-card {
            background: #ecf0f1;
            padding: 15px;
            border-radius: 6px;
            text-align: center;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #2c3e50;
        }
        .stat-label {
            color: #7f8c8d;
            font-size: 12px;
            text-transform: uppercase;
        }
        #log {
            height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
            background-color: #f8f9fa;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üóÑÔ∏è IndexedDB Storage Adapter Test</h1>
        
        <div class="test-section">
            <h2>Test Controls</h2>
            <button onclick="runAllTests()">üöÄ Run All Tests</button>
            <button onclick="testBasicOperations()">üìù Test Basic Operations</button>
            <button onclick="testBatchOperations()">üì¶ Test Batch Operations</button>
            <button onclick="testSHADetection()">üîç Test SHA Detection</button>
            <button onclick="testTransactions()">üîÑ Test Transactions</button>
            <button onclick="testQuotaManagement()">üíæ Test Quota Management</button>
            <button onclick="clearDatabase()" style="background-color: #e74c3c;">üóëÔ∏è Clear Database</button>
            <button onclick="clearLog()">üßπ Clear Log</button>
        </div>

        <div class="stats">
            <div class="stat-card">
                <div class="stat-value" id="totalTests">0</div>
                <div class="stat-label">Total Tests</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="passedTests">0</div>
                <div class="stat-label">Passed</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="failedTests">0</div>
                <div class="stat-label">Failed</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="storageSize">0 KB</div>
                <div class="stat-label">Storage Used</div>
            </div>
        </div>

        <div class="test-section">
            <h2>Test Results</h2>
            <div id="log"></div>
        </div>
    </div>

    <script type="module">
        // Mock types and interfaces for browser environment
        const ResourceType = {
            SCRIPTURE: 'scripture',
            NOTES: 'notes',
            WORDS: 'words',
            ACADEMY: 'academy'
        };

        // IndexedDB Storage Adapter (simplified for browser testing)
        class IndexedDBStorageAdapter {
            constructor(dbName = 'bt-studio-test') {
                this.dbName = dbName;
                this.db = null;
                this.isInitialized = false;
                this.dbVersion = 1;
            }

            async initialize() {
                if (this.isInitialized) return;

                log(`üì¶ Initializing IndexedDB: ${this.dbName}`, 'info');
                
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.dbVersion);

                    request.onerror = () => {
                        log(`‚ùå Failed to open IndexedDB: ${request.error}`, 'error');
                        reject(new Error(`Failed to open IndexedDB: ${request.error?.message}`));
                    };

                    request.onsuccess = () => {
                        this.db = request.result;
                        this.isInitialized = true;
                        log(`‚úÖ IndexedDB initialized successfully`, 'success');
                        resolve();
                    };

                    request.onupgradeneeded = (event) => {
                        log(`üîÑ Upgrading IndexedDB schema to version ${this.dbVersion}`, 'info');
                        const db = event.target.result;
                        this.createObjectStores(db);
                    };
                });
            }

            createObjectStores(db) {
                // Resource Metadata object store
                if (!db.objectStoreNames.contains('resource_metadata')) {
                    const metadataStore = db.createObjectStore('resource_metadata', { keyPath: 'id' });
                    metadataStore.createIndex('server_owner_language', ['server', 'owner', 'language'], { unique: false });
                    metadataStore.createIndex('type', 'type', { unique: false });
                    log(`üìã Created resource_metadata object store`, 'info');
                }

                // Resource Content object store
                if (!db.objectStoreNames.contains('resource_content')) {
                    const contentStore = db.createObjectStore('resource_content', { keyPath: 'key' });
                    contentStore.createIndex('resourceId_type', ['resourceId', 'type'], { unique: false });
                    contentStore.createIndex('bookCode', 'bookCode', { unique: false });
                    contentStore.createIndex('cachedUntil', 'cachedUntil', { unique: false });
                    contentStore.createIndex('sourceSha', 'sourceSha', { unique: false });
                    log(`üìã Created resource_content object store`, 'info');
                }
            }

            async saveResourceMetadata(metadata) {
                await this.initialize();
                log(`üíæ Saving ${metadata.length} metadata records`, 'info');

                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['resource_metadata'], 'readwrite');
                    const store = transaction.objectStore('resource_metadata');

                    transaction.onerror = () => reject(new Error(`Failed to save metadata: ${transaction.error?.message}`));
                    transaction.oncomplete = () => {
                        log(`‚úÖ Metadata saved successfully`, 'success');
                        resolve();
                    };

                    for (const meta of metadata) {
                        const dataToStore = {
                            ...meta,
                            lastUpdated: meta.lastUpdated.getTime(),
                            available: meta.available ? 1 : 0,
                            isAnchor: meta.isAnchor ? 1 : 0,
                            toc: meta.toc ? JSON.stringify(meta.toc) : undefined,
                            updated_at: Date.now()
                        };
                        store.put(dataToStore);
                    }
                });
            }

            async getResourceMetadata(server, owner, language) {
                await this.initialize();
                log(`üîç Fetching metadata for ${server}/${owner}/${language}`, 'info');

                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['resource_metadata'], 'readonly');
                    const store = transaction.objectStore('resource_metadata');
                    const index = store.index('server_owner_language');
                    const request = index.getAll([server, owner, language]);

                    request.onerror = () => reject(new Error(`Failed to fetch metadata: ${request.error?.message}`));
                    request.onsuccess = () => {
                        const results = request.result || [];
                        const metadata = results.map(row => ({
                            ...row,
                            lastUpdated: new Date(row.lastUpdated),
                            available: Boolean(row.available),
                            isAnchor: Boolean(row.isAnchor),
                            toc: row.toc ? JSON.parse(row.toc) : undefined
                        }));
                        log(`üìä Found ${metadata.length} metadata records`, 'success');
                        resolve(metadata);
                    };
                });
            }

            async saveResourceContent(content) {
                await this.initialize();
                log(`üíæ Saving content: ${content.key} (${content.size} bytes)`, 'info');

                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['resource_content'], 'readwrite');
                    const store = transaction.objectStore('resource_content');

                    transaction.onerror = () => reject(new Error(`Failed to save content: ${transaction.error?.message}`));
                    transaction.oncomplete = () => {
                        log(`‚úÖ Content saved successfully`, 'success');
                        resolve();
                    };

                    const dataToStore = {
                        ...content,
                        content: JSON.stringify(content.content),
                        lastFetched: content.lastFetched.getTime(),
                        cachedUntil: content.cachedUntil?.getTime() || undefined,
                        updated_at: Date.now()
                    };

                    store.put(dataToStore);
                });
            }

            async getResourceContent(key) {
                await this.initialize();
                log(`üîç Fetching content for key: ${key}`, 'info');

                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['resource_content'], 'readonly');
                    const store = transaction.objectStore('resource_content');
                    const request = store.get(key);

                    request.onerror = () => reject(new Error(`Failed to fetch content: ${request.error?.message}`));
                    request.onsuccess = () => {
                        const row = request.result;
                        
                        if (!row) {
                            log(`‚ùå Content not found for key: ${key}`, 'warning');
                            resolve(null);
                            return;
                        }

                        const content = {
                            key: row.key,
                            resourceId: row.resourceId,
                            server: row.server,
                            owner: row.owner,
                            language: row.language,
                            type: row.type,
                            bookCode: row.bookCode || undefined,
                            articleId: row.articleId || undefined,
                            content: typeof row.content === 'string' ? JSON.parse(row.content) : row.content,
                            lastFetched: new Date(row.lastFetched),
                            cachedUntil: row.cachedUntil ? new Date(row.cachedUntil) : undefined,
                            checksum: row.checksum || undefined,
                            size: row.size,
                            sourceSha: row.sourceSha || undefined,
                            sourceCommit: row.sourceCommit || undefined
                        };

                        log(`‚úÖ Content found: ${content.size} bytes`, 'success');
                        resolve(content);
                    };
                });
            }

            async getStorageInfo() {
                await this.initialize();

                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['resource_content'], 'readonly');
                    const store = transaction.objectStore('resource_content');

                    let totalSize = 0;
                    let itemCount = 0;

                    const request = store.openCursor();
                    
                    request.onsuccess = (event) => {
                        const cursor = event.target.result;
                        if (cursor) {
                            totalSize += cursor.value.size || 0;
                            itemCount++;
                            cursor.continue();
                        } else {
                            resolve({
                                totalSize,
                                availableSpace: -1,
                                itemCount,
                                lastCleanup: new Date()
                            });
                        }
                    };

                    request.onerror = () => reject(new Error(`Failed to calculate storage info: ${request.error?.message}`));
                });
            }

            async checkQuota() {
                try {
                    if ('storage' in navigator && 'estimate' in navigator.storage) {
                        const estimate = await navigator.storage.estimate();
                        const used = estimate.usage || 0;
                        const total = estimate.quota || 0;
                        const available = Math.max(0, total - used);

                        return {
                            used,
                            available,
                            total,
                            nearLimit: used > (total * 0.8)
                        };
                    }
                } catch (error) {
                    log(`‚ö†Ô∏è Could not get storage quota: ${error.message}`, 'warning');
                }

                const info = await this.getStorageInfo();
                const defaultQuota = 50 * 1024 * 1024; // 50MB
                
                return {
                    used: info.totalSize,
                    available: Math.max(0, defaultQuota - info.totalSize),
                    total: defaultQuota,
                    nearLimit: info.totalSize > (defaultQuota * 0.8)
                };
            }

            async clearAllContent() {
                await this.initialize();
                log(`üßπ Clearing all content`, 'info');

                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['resource_content'], 'readwrite');
                    const store = transaction.objectStore('resource_content');

                    transaction.onerror = () => reject(new Error(`Failed to clear content: ${transaction.error?.message}`));
                    transaction.oncomplete = () => {
                        log(`‚úÖ All content cleared`, 'success');
                        resolve();
                    };

                    store.clear();
                });
            }

            async deleteDatabase() {
                if (this.db) {
                    this.db.close();
                    this.db = null;
                    this.isInitialized = false;
                }
                
                return new Promise((resolve, reject) => {
                    log(`üóëÔ∏è Deleting database: ${this.dbName}`, 'info');
                    
                    const deleteRequest = indexedDB.deleteDatabase(this.dbName);
                    
                    deleteRequest.onerror = () => reject(new Error(`Failed to delete database: ${deleteRequest.error?.message}`));
                    deleteRequest.onsuccess = () => {
                        log(`‚úÖ Database deleted successfully`, 'success');
                        resolve();
                    };
                    deleteRequest.onblocked = () => {
                        log(`‚ö†Ô∏è Database deletion blocked`, 'warning');
                        resolve();
                    };
                });
            }
        }

        // Test framework
        let testStats = {
            total: 0,
            passed: 0,
            failed: 0
        };

        function log(message, type = 'info') {
            const logElement = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            const className = type;
            
            const logEntry = document.createElement('div');
            logEntry.className = `test-result ${className}`;
            logEntry.innerHTML = `[${timestamp}] ${message}`;
            
            logElement.appendChild(logEntry);
            logElement.scrollTop = logElement.scrollHeight;
            
            console.log(`[${timestamp}] ${message}`);
        }

        function updateStats() {
            document.getElementById('totalTests').textContent = testStats.total;
            document.getElementById('passedTests').textContent = testStats.passed;
            document.getElementById('failedTests').textContent = testStats.failed;
        }

        async function updateStorageStats() {
            try {
                const adapter = new IndexedDBStorageAdapter('bt-studio-test');
                const info = await adapter.getStorageInfo();
                document.getElementById('storageSize').textContent = `${Math.round(info.totalSize / 1024)} KB`;
            } catch (error) {
                document.getElementById('storageSize').textContent = 'N/A';
            }
        }

        async function runTest(name, testFn) {
            testStats.total++;
            log(`üß™ Running test: ${name}`, 'info');
            
            try {
                await testFn();
                testStats.passed++;
                log(`‚úÖ Test passed: ${name}`, 'success');
            } catch (error) {
                testStats.failed++;
                log(`‚ùå Test failed: ${name} - ${error.message}`, 'error');
                console.error(error);
            }
            
            updateStats();
            await updateStorageStats();
        }

        // Test functions
        async function testBasicOperations() {
            await runTest('Basic Metadata Operations', async () => {
                const adapter = new IndexedDBStorageAdapter('bt-studio-test');
                
                // Test metadata save and retrieve
                const metadata = [{
                    id: 'test-scripture',
                    server: 'git.door43.org',
                    owner: 'unfoldingWord',
                    language: 'en',
                    type: ResourceType.SCRIPTURE,
                    title: 'Test Scripture',
                    description: 'A test scripture resource',
                    name: 'test-scripture-en',
                    version: 'v1.0.0',
                    lastUpdated: new Date(),
                    available: true,
                    toc: { books: [{ code: 'gen', name: 'Genesis', chapters: 50, testament: 'OT' }] },
                    isAnchor: true
                }];

                await adapter.saveResourceMetadata(metadata);
                const retrieved = await adapter.getResourceMetadata('git.door43.org', 'unfoldingWord', 'en');
                
                if (retrieved.length !== 1) throw new Error('Metadata count mismatch');
                if (retrieved[0].id !== 'test-scripture') throw new Error('Metadata ID mismatch');
            });

            await runTest('Basic Content Operations', async () => {
                const adapter = new IndexedDBStorageAdapter('bt-studio-test');
                
                // Test content save and retrieve
                const content = {
                    key: 'git.door43.org/unfoldingWord/en/test-scripture/gen',
                    resourceId: 'test-scripture',
                    server: 'git.door43.org',
                    owner: 'unfoldingWord',
                    language: 'en',
                    type: ResourceType.SCRIPTURE,
                    bookCode: 'gen',
                    content: {
                        book: 'Genesis',
                        bookCode: 'GEN',
                        chapters: [
                            {
                                number: 1,
                                verses: [
                                    { number: 1, text: 'In the beginning...', reference: 'GEN 1:1' }
                                ]
                            }
                        ]
                    },
                    lastFetched: new Date(),
                    cachedUntil: new Date(Date.now() + 86400000), // 24 hours
                    checksum: 'abc123',
                    size: 1024,
                    sourceSha: 'sha123456',
                    sourceCommit: 'commit789'
                };

                await adapter.saveResourceContent(content);
                const retrieved = await adapter.getResourceContent(content.key);
                
                if (!retrieved) throw new Error('Content not found');
                if (retrieved.key !== content.key) throw new Error('Content key mismatch');
                if (retrieved.sourceSha !== content.sourceSha) throw new Error('SHA mismatch');
            });
        }

        async function testBatchOperations() {
            await runTest('Batch Content Operations', async () => {
                const adapter = new IndexedDBStorageAdapter('bt-studio-test');
                
                // Create multiple content items
                const contents = [];
                for (let i = 1; i <= 5; i++) {
                    contents.push({
                        key: `git.door43.org/unfoldingWord/en/test-scripture/book${i}`,
                        resourceId: 'test-scripture',
                        server: 'git.door43.org',
                        owner: 'unfoldingWord',
                        language: 'en',
                        type: ResourceType.SCRIPTURE,
                        bookCode: `book${i}`,
                        content: { book: `Book ${i}`, chapters: [] },
                        lastFetched: new Date(),
                        size: 512 * i,
                        sourceSha: `sha${i}${i}${i}`
                    });
                }

                // Save individually to test retrieval
                for (const content of contents) {
                    await adapter.saveResourceContent(content);
                }

                // Test storage info
                const info = await adapter.getStorageInfo();
                if (info.itemCount < 5) throw new Error('Insufficient items in storage');
                
                log(`üìä Storage contains ${info.itemCount} items, ${Math.round(info.totalSize / 1024)} KB`, 'info');
            });
        }

        async function testSHADetection() {
            await runTest('SHA-based Change Detection', async () => {
                const adapter = new IndexedDBStorageAdapter('bt-studio-test');
                
                // Save content with original SHA
                const originalContent = {
                    key: 'git.door43.org/unfoldingWord/en/test-scripture/sha-test',
                    resourceId: 'test-scripture',
                    server: 'git.door43.org',
                    owner: 'unfoldingWord',
                    language: 'en',
                    type: ResourceType.SCRIPTURE,
                    bookCode: 'sha-test',
                    content: { version: 1, text: 'Original content' },
                    lastFetched: new Date(),
                    size: 256,
                    sourceSha: 'original-sha-123',
                    sourceCommit: 'commit-abc'
                };

                await adapter.saveResourceContent(originalContent);
                
                // Retrieve and verify SHA
                const retrieved = await adapter.getResourceContent(originalContent.key);
                if (!retrieved) throw new Error('Content not found');
                if (retrieved.sourceSha !== 'original-sha-123') throw new Error('Original SHA mismatch');

                // Update with new SHA
                const updatedContent = {
                    ...originalContent,
                    content: { version: 2, text: 'Updated content' },
                    sourceSha: 'updated-sha-456',
                    sourceCommit: 'commit-def',
                    lastFetched: new Date()
                };

                await adapter.saveResourceContent(updatedContent);
                
                // Verify SHA change
                const retrievedUpdated = await adapter.getResourceContent(originalContent.key);
                if (!retrievedUpdated) throw new Error('Updated content not found');
                if (retrievedUpdated.sourceSha !== 'updated-sha-456') throw new Error('Updated SHA mismatch');
                if (retrievedUpdated.content.version !== 2) throw new Error('Content version mismatch');

                log(`üîç SHA detection test: original-sha-123 ‚Üí updated-sha-456`, 'info');
            });
        }

        async function testTransactions() {
            await runTest('Transaction Operations', async () => {
                const adapter = new IndexedDBStorageAdapter('bt-studio-test');
                
                // Test that we can perform multiple operations
                // (IndexedDB transactions are handled internally)
                const content1 = {
                    key: 'transaction-test-1',
                    resourceId: 'test-resource',
                    server: 'test.server',
                    owner: 'testOwner',
                    language: 'en',
                    type: ResourceType.SCRIPTURE,
                    content: { data: 'test1' },
                    lastFetched: new Date(),
                    size: 100
                };

                const content2 = {
                    key: 'transaction-test-2',
                    resourceId: 'test-resource',
                    server: 'test.server',
                    owner: 'testOwner',
                    language: 'en',
                    type: ResourceType.SCRIPTURE,
                    content: { data: 'test2' },
                    lastFetched: new Date(),
                    size: 100
                };

                // Save both items
                await adapter.saveResourceContent(content1);
                await adapter.saveResourceContent(content2);

                // Verify both exist
                const retrieved1 = await adapter.getResourceContent(content1.key);
                const retrieved2 = await adapter.getResourceContent(content2.key);

                if (!retrieved1 || !retrieved2) throw new Error('Transaction test items not found');
                
                log(`üîÑ Transaction test: saved and retrieved 2 items`, 'info');
            });
        }

        async function testQuotaManagement() {
            await runTest('Quota Management', async () => {
                const adapter = new IndexedDBStorageAdapter('bt-studio-test');
                
                // Test quota information
                const quota = await adapter.checkQuota();
                
                if (typeof quota.used !== 'number') throw new Error('Invalid quota.used');
                if (typeof quota.total !== 'number') throw new Error('Invalid quota.total');
                if (typeof quota.nearLimit !== 'boolean') throw new Error('Invalid quota.nearLimit');

                log(`üíæ Quota: ${Math.round(quota.used / 1024)} KB used of ${Math.round(quota.total / 1024 / 1024)} MB total`, 'info');
                
                // Test storage info
                const info = await adapter.getStorageInfo();
                if (typeof info.totalSize !== 'number') throw new Error('Invalid storage info');
                if (typeof info.itemCount !== 'number') throw new Error('Invalid item count');

                log(`üìä Storage: ${info.itemCount} items, ${Math.round(info.totalSize / 1024)} KB`, 'info');
            });
        }

        async function runAllTests() {
            log('üöÄ Starting comprehensive IndexedDB test suite...', 'info');
            testStats = { total: 0, passed: 0, failed: 0 };
            
            await testBasicOperations();
            await testBatchOperations();
            await testSHADetection();
            await testTransactions();
            await testQuotaManagement();
            
            const successRate = testStats.total > 0 ? Math.round((testStats.passed / testStats.total) * 100) : 0;
            log(`üéâ Test suite completed: ${testStats.passed}/${testStats.total} tests passed (${successRate}%)`, 
                 successRate === 100 ? 'success' : 'warning');
        }

        async function clearDatabase() {
            try {
                const adapter = new IndexedDBStorageAdapter('bt-studio-test');
                await adapter.deleteDatabase();
                testStats = { total: 0, passed: 0, failed: 0 };
                updateStats();
                await updateStorageStats();
                log('üóëÔ∏è Database cleared successfully', 'success');
            } catch (error) {
                log(`‚ùå Failed to clear database: ${error.message}`, 'error');
            }
        }

        function clearLog() {
            document.getElementById('log').innerHTML = '';
        }

        // Make functions globally available
        window.runAllTests = runAllTests;
        window.testBasicOperations = testBasicOperations;
        window.testBatchOperations = testBatchOperations;
        window.testSHADetection = testSHADetection;
        window.testTransactions = testTransactions;
        window.testQuotaManagement = testQuotaManagement;
        window.clearDatabase = clearDatabase;
        window.clearLog = clearLog;

        // Initialize stats on page load
        updateStats();
        updateStorageStats();
        
        log('üåê IndexedDB Storage Adapter Test Suite Ready', 'info');
        log('üí° Click "Run All Tests" to start comprehensive testing', 'info');
    </script>
</body>
</html>

